(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('standardized-audio-context')) :
	typeof define === 'function' && define.amd ? define(['exports', 'standardized-audio-context'], factory) :
	(factory((global.webAudioBeatDetector = global.webAudioBeatDetector || {}),global.standardizedAudioContext));
}(this, (function (exports,standardizedAudioContext) { 'use strict';

var INITIAL_THRESHOLD = 0.9;
var MINUMUM_NUMBER_OF_PEAKS = 30;
var MINIMUM_THRESHOLD = 0.3;
var countIntervalsBetweenNearbyPeaks = function countIntervalsBetweenNearbyPeaks(peaks) {
    var intervalCounts = [];
    peaks.forEach(function (peak, index) {
        var length = Math.min(peaks.length - index, 10);

        var _loop = function _loop(i) {
            var interval = peaks[index + i] - peak;
            var foundInterval = intervalCounts.some(function (intervalCount) {
                if (intervalCount.interval === interval) {
                    intervalCount.count += 1;
                    return true;
                }
                return false;
            });
            if (!foundInterval) {
                intervalCounts.push({
                    count: 1,
                    interval: interval
                });
            }
        };

        for (var i = 0; i < length; i += 1) {
            _loop(i);
        }
    });
    return intervalCounts;
};
var getPeaksAtThreshold = function getPeaksAtThreshold(data, threshold, sampleRate) {
    var peaks = [];
    var length = data.length;
    for (var i = 0; i < length; i += 1) {
        if (data[i] > threshold) {
            peaks.push(i);
            // Skip forward 1/4s to get past this peak.
            i += sampleRate / 4 - 1;
        }
    }
    return peaks;
};
var groupNeighborsByTempo = function groupNeighborsByTempo(intervals, sampleRate) {
    var tempoCounts = [];
    intervals.filter(function (intervalCount) {
        return intervalCount.interval !== 0;
    }).forEach(function (intervalCount) {
        // Convert an interval to tempo
        var theoreticalTempo = 60 / (intervalCount.interval / sampleRate);
        // Adjust the tempo to fit within the 90-180 BPM range
        while (theoreticalTempo < 90) {
            theoreticalTempo *= 2;
        }
        while (theoreticalTempo > 180) {
            theoreticalTempo /= 2;
        }
        var foundTempo = tempoCounts.some(function (tempoCount) {
            if (tempoCount.tempo === theoreticalTempo) {
                tempoCount.count += intervalCount.count;
                return true;
            }
            return false;
        });
        if (!foundTempo) {
            tempoCounts.push({
                count: intervalCount.count,
                tempo: theoreticalTempo
            });
        }
    });
    return tempoCounts;
};
var analyze = function analyze(audioBuffer) {
    var offlineAudioContext = new standardizedAudioContext.OfflineAudioContext(audioBuffer.numberOfChannels, audioBuffer.length, audioBuffer.sampleRate);
    var biquadFilter = offlineAudioContext.createBiquadFilter();
    var bufferSourceNode = offlineAudioContext.createBufferSource();
    biquadFilter.frequency.value = 200;
    biquadFilter.type = 'lowpass';
    bufferSourceNode.buffer = audioBuffer;
    // @todo Remove this ugly hack again when possible.
    bufferSourceNode.connect(biquadFilter).connect(offlineAudioContext.destination);
    bufferSourceNode.start(0);
    return offlineAudioContext.startRendering().then(function (renderedBuffer) {
        var peaks = [];
        var threshold = INITIAL_THRESHOLD;
        while (peaks.length < MINUMUM_NUMBER_OF_PEAKS && threshold >= MINIMUM_THRESHOLD) {
            peaks = getPeaksAtThreshold(renderedBuffer.getChannelData(0), threshold, renderedBuffer.sampleRate);
            threshold -= 0.05;
        }
        var intervals = countIntervalsBetweenNearbyPeaks(peaks);
        var groups = groupNeighborsByTempo(intervals, renderedBuffer.sampleRate);
        groups.sort(function (a, b) {
            return b.count - a.count;
        });
        return Math.round(groups[0].tempo);
    });
};

exports.analyze = analyze;
exports.isSupported = standardizedAudioContext.isSupported;

Object.defineProperty(exports, '__esModule', { value: true });

})));
